//
// Copyright © 2025 Roland Lariotte. Under the MIT License.
//

import Foundation

/// Retrieves input and output paths from the `IconsProcessor` plugin arguments.
let arguments = ProcessInfo().arguments
if arguments.count < 3 {
  print("Missing arguments `input` and `output` from `IconsProcessor` plugin.")
  exit(1)
}

let (input, output) = (arguments[1], arguments[2])

/// Represents the contents of an asset catalog entry.
struct ContentsData: Decodable {
  let images: [Image]

  /// Defines an image entry inside the asset catalog.
  struct Image: Decodable {
    let filename: String?
  }
}

/// Holds the generated Swift code for icons.
var generatedCode = """
//
// Copyright © 2025 Roland Lariotte. Under the MIT License.
//

// File auto-generated by the `IconsProcessor` plugin within the CanvasKit package.

import SwiftUI

/// Enum representing all available icons in `Icons.xcassets`.
public enum CKIconAsset: String, CaseIterable {


"""

var brandIcons: Set<String> = []
var styledIcons: Set<String> = [] // Tracks icons supporting Regular/Filled

/// Scans `Icons.xcassets` for `.imageset` directories and categorizes icons.
try FileManager
  .default
  .subpathsOfDirectory(atPath: input)
  .forEach { item in
    guard item.hasSuffix("imageset") else { return }

    let contentsURL = URL(fileURLWithPath: input)
      .appendingPathComponent(item)
      .appendingPathComponent("Contents.json")

    let data = try Data(contentsOf: contentsURL)
    let contents = try JSONDecoder().decode(ContentsData.self, from: data)

    let hasIcon = contents.images.contains { $0.filename != nil }
    guard hasIcon else { return }

    let pathComponents = item.split(separator: "/")
    guard pathComponents.count >= 2 else { return } // Ensure folder structure exists

    let folder = String(pathComponents[pathComponents.count - 2]) // Parent folder (Brands, Regular, Filled)
    let baseName = String(pathComponents.last!).replacingOccurrences(of: ".imageset", with: "")

    /// Detects whether the icon is Regular or Filled
    let isRegular = folder == "Regular"
    let isFilled = folder == "Filled"

    /// Removes `Regular` and `Filled` from the base name for consistency
    let cleanName = baseName
      .replacingOccurrences(of: "Regular", with: "")
      .replacingOccurrences(of: "Filled", with: "")

    let formattedBaseName = cleanName.prefix(1).lowercased() + cleanName.dropFirst()

    if isRegular || isFilled {
      styledIcons.insert(formattedBaseName) // Track icons with style support
    }

    // Always add case, ensuring it's not duplicated
    brandIcons.insert(formattedBaseName)
  }

/// Append all icons (no duplicates)
generatedCode.append(
  brandIcons.sorted().map { "  case \($0)\n" }.joined()
)

generatedCode.append("""
}

/// Defines the available styles for ``CKIcon``.
public enum CKIconStyle {

  case regular, filled

  /// Provides the correct suffix for the image name.
  var suffix: String {
    switch self {
    case .regular: "Regular"
    case .filled: "Filled"
    }
  }
}

extension CKIconAsset {

  /// Returns the correct image based on the style.
  public func image(for style: CKIconStyle) -> Image {
    let baseName = String(describing: self)

    if CKIconAsset.styledIcons.contains(baseName) {
      return Image("\\(baseName)\\(style.suffix)", bundle: .module)
    }
    return Image(baseName, bundle: .module)
  }

  /// Indicates whether the icon supports different styles.
  /// Icons that support multiple styles are stored in ``CKIconAsset.styledIcons``.
  public var isStylable: Bool { CKIconAsset.styledIcons.contains(rawValue) }

  /// A set of icon names that support styles (Regular / Filled).
  static let styledIcons: Set<String> = [

""")

generatedCode.append(
  styledIcons.sorted().map { "    \"\($0)\"" }.joined(separator: ",\n")
)

generatedCode.append("""

  ]
}

""")

/// Writes the generated Swift code to the output file.
try generatedCode.write(to: URL(fileURLWithPath: output), atomically: true, encoding: .utf8)
